# 硬件综合实践 - 8051 单片机项目

本仓库用于存放“硬件综合实践”课程的相关代码。

## 项目说明

本项目将根据课程进度渐进式地补充和修改代码。
- **历史版本与功能**：请通过 Git 的 `commit history` 和 `tag` 查看不同阶段的功能实现和历史版本。

## 项目结构

- [main.c](main.c) - 主程序文件
- [delay.c](delay.c) / [delay.h](delay.h) - 延时函数实现
- [utils.h](utils.h) - 工具宏定义
- `Objects/` - 编译输出文件
- `Listings/` - 编译列表文件

## 开发环境要求

### 必需软件

1. **Keil uVision 5**
   - 用于编译和调试 8051 单片机程序
   - 下载地址：https://www.keil.com/demo/eval/c51.htm

2. **Visual Studio Code**
   - 代码编辑器

3. **Keil Assistant 插件**
   - 在 VS Code 中集成 Keil 开发环境
   - 安装方法：
     - 打开 VS Code
     - 按 `Ctrl+Shift+X` 打开扩展面板
     - 搜索 "Keil Assistant" 或访问：https://marketplace.visualstudio.com/items?itemName=candycium.keil-assistant-new
     - 点击安装

## 使用方法

1. 安装上述开发环境
2. 使用 VS Code 打开项目文件夹
3. 使用 Keil Assistant 插件关联 Keil 路径并编译项目
4. 将生成的 HEX 文件烧录到 8051 单片机

---

## 核心算法详解

### 1. 调度场算法 (Shunting Yard Algorithm)

#### 算法目的
将**中缀表达式**(如 `3 + 4 * 2`)转换为**逆波兰表达式/后缀表达式**(如 `3 4 2 * +`)

#### 为什么需要这个转换？
- 中缀表达式需要处理运算符优先级和括号
- 后缀表达式不需要括号，不需要考虑优先级
- 后缀表达式的求值过程非常简单高效

#### 核心思想
使用一个**运算符栈**来处理运算符优先级和括号匹配。

#### 算法步骤（实现位置：[calculator.c](calculator.c#L407-L454)）

1. **遇到数字** → 直接输出到结果队列
2. **遇到运算符** → 
   - 弹出栈中**优先级 ≥ 当前运算符**的所有运算符到输出
   - 将当前运算符压入栈
3. **遇到左括号 `(`** → 直接压入栈（作为"屏障"）
4. **遇到右括号 `)`** → 
   - 弹出栈中运算符到输出，直到遇到左括号
   - 左括号出栈但不输出
5. **表达式结束** → 弹出栈中所有剩余运算符

#### 示例演示

**输入**: `3 + 4 * 2`

| 步骤 | 读取 | 运算符栈 | 输出队列 | 说明 |
|-----|------|---------|---------|------|
| 1 | 3 | `[ ]` | `[3]` | 数字直接输出 |
| 2 | + | `[+]` | `[3]` | 栈空，`+` 入栈 |
| 3 | 4 | `[+]` | `[3, 4]` | 数字直接输出 |
| 4 | * | `[+, *]` | `[3, 4]` | `*` 优先级 > `+`，直接入栈 |
| 5 | 2 | `[+, *]` | `[3, 4, 2]` | 数字直接输出 |
| 6 | 结束 | `[ ]` | `[3, 4, 2, *, +]` | 弹出所有运算符 |

**结果**: `3 4 2 * +` （先算 4×2=8，再算 3+8=11）

#### 括号处理示例

**输入**: `(3 + 4) * 2`

| 步骤 | 读取 | 运算符栈 | RPN输出 | 说明 |
|-----|------|---------|---------|------|
| 1 | ( | `[(]` | `[ ]` | 左括号入栈 |
| 2 | 3 | `[(]` | `[3]` | 数字输出 |
| 3 | + | `[(, +]` | `[3]` | 运算符入栈 |
| 4 | 4 | `[(, +]` | `[3, 4]` | 数字输出 |
| 5 | ) | `[ ]` | `[3, 4, +]` | 弹出 `+`，丢弃 `(` |
| 6 | * | `[*]` | `[3, 4, +]` | 运算符入栈 |
| 7 | 2 | `[*]` | `[3, 4, +, 2]` | 数字输出 |
| 8 | 结束 | `[ ]` | `[3, 4, +, 2, *]` | 弹出 `*` |

**结果**: `3 4 + 2 *` （先算 3+4=7，再算 7×2=14）

#### 关键代码解析

**运算符优先级定义**（[calculator.c](calculator.c#L20-L35)）:
```c
static void InitOperatorPrecedence(void)
{
  operatorPrecedence['('] = 0;  // 括号优先级最低
  operatorPrecedence[')'] = 0;
  operatorPrecedence['+'] = 1;  // 加减优先级为1
  operatorPrecedence['-'] = 1;
  operatorPrecedence['*'] = 2;  // 乘除优先级为2
  operatorPrecedence['/'] = 2;
}
```

**处理运算符的核心逻辑**（[calculator.c](calculator.c#L372-L391)）:
```c
static void HandleOperatorToken(Token token, Token xdata *rpnOutput, unsigned char *rpnLen)
{
  // 弹出优先级 ≥ 当前运算符的所有运算符
  while (!CharStack_IsEmpty())
  {
    topOp = CharStack_Peek();
    // 遇到左括号或更低优先级，停止弹出
    if (topOp == '(' || GetPrecedence(topOp) < GetPrecedence(token.op))
    {
      break;
    }
    // 弹出高优先级运算符到输出
    outputToken.type = TOKEN_OPERATOR;
    outputToken.op = CharStack_Pop();
    rpnOutput[(*rpnLen)++] = outputToken;
  }
  // 当前运算符入栈
  CharStack_Push(token.op);
}
```

---

### 2. 逆波兰表达式求值 (RPN Evaluation)

#### 算法目的
计算**后缀表达式**的值

#### 核心思想
使用一个**操作数栈**:
- 遇到数字 → 压入栈
- 遇到运算符 → 弹出2个数，计算后结果压入栈
- 最后栈中剩下的唯一元素就是最终结果

#### 算法步骤（实现位置：[calculator.c](calculator.c#L457-L507)）

**输入**: `3 4 2 * +`

| 步骤 | 读取 | 栈状态 | 操作说明 |
|-----|------|--------|---------|
| 1 | 3 | `[3]` | 数字压入栈 |
| 2 | 4 | `[3, 4]` | 数字压入栈 |
| 3 | 2 | `[3, 4, 2]` | 数字压入栈 |
| 4 | * | `[3, 8]` | 弹出4和2，计算 4×2=8，结果入栈 |
| 5 | + | `[11]` | 弹出3和8，计算 3+8=11，结果入栈 |

**最终结果**: `11`

#### 关键代码解析

```c
static unsigned char EvaluateRPN(float *result)
{
  FloatStack_Init();  // 初始化操作数栈
  
  for (i = 0; i < TokenQueue_Length(); i++)
  {
    token = *TokenQueue_Get(i);
    
    if (token.type == TOKEN_NUMBER)
    {
      // 数字直接入栈
      FloatStack_Push(token.value);
    }
    else if (token.type == TOKEN_OPERATOR)
    {
      // 弹出两个操作数（注意顺序！）
      operand2 = FloatStack_Pop();  // 后弹出的是第二个操作数
      operand1 = FloatStack_Pop();  // 先弹出的是第一个操作数
      
      // 计算: operand1 op operand2
      PerformOperation(token.op, operand1, operand2, &opResult);
      
      // 结果压入栈
      FloatStack_Push(opResult);
    }
  }
  
  // 栈中应该只剩一个结果
  *result = FloatStack_Pop();
  return CALC_OK;
}
```

**为什么操作数顺序很重要？**

对于减法和除法，操作数顺序会影响结果：
- 正确: `5 - 3 = 2`
- 错误: `3 - 5 = -2`

因为栈是后进先出(LIFO)，所以：
```c
operand2 = FloatStack_Pop();  // 后弹出 → 3
operand1 = FloatStack_Pop();  // 先弹出 → 5
result = operand1 - operand2; // 5 - 3 = 2 ✓
```

---

### 3. 完整计算流程

以计算 `(3 + 4) * 2` 为例：

#### 第一步：词法分析 (Tokenize)
将字符串转换为 Token 序列（[calculator.c](calculator.c#L199-L259)）

```
输入字符串: "(3+4)*2"
Token 序列: [(, 3, +, 4, ), *, 2]
```

**负数处理**：
- 在表达式开头: `-5`
- 运算符后: `3 + -5`
- 左括号后: `(-5)`

这些情况下，负号被视为数字的一部分。

#### 第二步：调度场算法
转换为 RPN（上面已详细说明）
```
Token 序列: [(, 3, +, 4, ), *, 2]
RPN 输出: [3, 4, +, 2, *]
```

#### 第三步：RPN 求值
```
处理 3: 栈 = [3]
处理 4: 栈 = [3, 4]
处理 +: 栈 = [7]      (3+4)
处理 2: 栈 = [7, 2]
处理 *: 栈 = [14]     (7*2)
```

**最终答案**: `14`

---

### 4. 常见面试问题

#### Q1: 为什么要转换成逆波兰表达式？
**答**: 
- **不需要括号**：括号信息已经在转换过程中处理
- **不需要考虑运算符优先级**：后缀表达式的计算顺序是唯一的
- **计算过程简单**：只需要一个栈，遇到数字入栈，遇到运算符弹出计算
- **适合机器执行**：线性扫描，没有回溯

#### Q2: 运算符优先级如何处理？
**答**: 在调度场算法中，通过比较优先级：
- `*` `/` 的优先级为 2
- `+` `-` 的优先级为 1
- 当遇到新运算符时，弹出所有优先级 ≥ 它的运算符
- 这样保证了高优先级运算符先被计算

#### Q3: 括号如何处理？
**答**: 
- **左括号** `(`：直接压入栈，作为"屏障"，阻止运算符被弹出
- **右括号** `)`：触发弹出操作，直到遇到匹配的左括号
- 左括号的优先级设为0，确保任何运算符都不会越过它

#### Q4: 如何检测语法错误？
**答**: 
- **括号不匹配**：右括号数量 > 左括号数量，或处理完后还有左括号
- **操作数不足**：RPN求值时，遇到运算符但栈中元素 < 2
- **表达式不完整**：RPN求值结束后，栈中不是恰好1个元素
- **除零错误**：除法运算时检查除数是否为0

#### Q5: 为什么栈的大小够用？
**答**: 
- **运算符栈**：最坏情况是嵌套括号，深度受表达式长度限制
- **操作数栈**：RPN求值时，栈的最大深度不会超过操作数的数量
- 本项目中表达式最大32字符，栈大小设为32完全足够

---

### 5. 相关文件说明

- **[calculator.c](calculator.c)** - 计算器核心算法实现
- **[calculator.h](calculator.h)** - 计算器接口定义
- **[token.h](token.h)** - Token 类型定义
- **[stack.c](stack.c)** / **[stack.h](stack.h)** - 栈数据结构实现
- **[main.c](main.c)** - 主程序，处理键盘输入和LCD显示

---

### 6. 算法时间复杂度

- **词法分析**：O(n)，n 为表达式长度
- **调度场算法**：O(n)，每个 Token 最多入栈出栈各一次
- **RPN 求值**：O(n)，每个 Token 处理一次

**总时间复杂度**：O(n)，非常高效！
